/*! enduring-stash 09-11-2013 */
!function() {
    "use strict";
    var enduring = window.enduring || void 0;
    if (!enduring) throw "Enduring Stash: Enduring Stash is missing!";
    var WebSQLStorage = function() {
        var dbSize = 5242880;
        this.storage = openDatabase("EnduringStash", "1", "Enduring Stash Data Storage", dbSize), 
        this.storage.transaction(function(tx) {
            var createTableStatement = "CREATE TABLE IF NOT EXISTS Stash (id STRING PRIMARY KEY, value TEXT)", statementParams = [], successCallback = null, errorCallback = this.onError;
            tx.executeSql(createTableStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    };
    return WebSQLStorage.prototype.onError = function(error) {
        console.error(error);
    }, WebSQLStorage.prototype.get = function(key, promise) {
        var self = this;
        this.storage.transaction(function(tx) {
            var sqlStatement = "SELECT value FROM Stash WHERE id = ?", statementParams = [ key ], successCallback = function(tx, result) {
                if (result.rows.length > 1) return promise.reject("More than one item has the same key"), 
                void 0;
                if (0 === result.rows.length) return promise.resolve(void 0), void 0;
                var rawValue = result.rows.item(0).value, value = self.unstringify(rawValue);
                promise.resolve(value);
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.getAll = function(keyPrefix, promise) {
        var self = this;
        this.storage.transaction(function(tx) {
            var sqlStatement = "SELECT value FROM Stash WHERE id LIKE ?", statementParams = [ keyPrefix + "%" ], successCallback = function(tx, result) {
                for (var data = [], i = 0; i < result.rows.length; i++) {
                    var item = result.rows.item(i).value;
                    self.unstringify(item), data.push(self.unstringify(item));
                }
                promise.resolve(data);
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.set = function(key, value, promise) {
        var self = this;
        this.storage.transaction(function(tx) {
            var sqlStatement = "SELECT COUNT(*) as count FROM Stash WHERE id = ?", statementParams = [ key ], successCallback = function(tx, result) {
                var itemCount = result.rows.item(0).count;
                return itemCount > 0 ? self.update(key, value, promise) : self.add(key, value, promise);
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.add = function(key, value, promise) {
        var self = this;
        this.storage.transaction(function(tx) {
            var sqlStatement = "INSERT INTO Stash (id, value) VALUES (?, ?)", statementParams = [ key, self.stringify(value) ], successCallback = function(tx, result) {
                return 1 !== result.rowsAffected ? (promise.reject("Value was not updated"), void 0) : (promise.resolve(value), 
                void 0);
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.update = function(key, value, promise) {
        var self = this;
        this.storage.transaction(function(tx) {
            var sqlStatement = "UPDATE Stash SET value = ? WHERE id = ?", statementParams = [ self.stringify(value), key ], successCallback = function(tx, result) {
                1 === result.rowsAffected ? promise.resolve(value) : promise.reject("Item was not updated");
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.remove = function(key, promise) {
        this.storage.transaction(function(tx) {
            var sqlStatement = "DELETE FROM Stash WHERE id = ?", statementParams = [ key ], successCallback = function() {
                promise.resolve();
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.contains = function(key, promise) {
        this.storage.transaction(function(tx) {
            var sqlStatement = "SELECT * FROM Stash WHERE id = ?", statementParams = [ key ], successCallback = function(tx, result) {
                var itemCount = result.rows.length;
                promise.resolve(itemCount > 0);
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, WebSQLStorage.prototype.removeAll = function(promise) {
        this.storage.transaction(function(tx) {
            var sqlStatement = "DELETE FROM Stash", statementParams = [], successCallback = function() {
                promise.resolve();
            }, errorCallback = function(tx, error) {
                promise.reject(error);
            };
            tx.executeSql(sqlStatement, statementParams, successCallback, errorCallback);
        }, this.onError);
    }, window.openDatabase ? (enduring.provider.registerProvider("WebSQL", WebSQLStorage), 
    WebSQLStorage) : void 0;
}();