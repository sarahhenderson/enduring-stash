/*! enduring-stash 09-11-2013 */
window.enduring = function() {
    "use strict";
    var Q = window.Q || void 0, $ = window.jQuery || void 0, JSON = window.JSON || void 0;
    if (!Q && !jQuery) throw "Enduring Stash: Promise library unavailable! Include https://github.com/kriskowal/q/blob/master/q.js to fix.";
    if (!JSON) throw "Enduring Stash: JSON unavailable! Include http://www.json.org/json2.js to fix.";
    var Stash = function(name, provider) {
        if (this.provider = provider, !this.provider) throw "Cannot create a stash without a provider";
        if (this.keyPrefix = this.createKeyPrefix(name), !this.keyPrefix) throw "Unable to create key prefix";
    };
    Stash.prototype.createKeyPrefix = function(name) {
        var prefix = "_stash_";
        return prefix += name ? name + "_" : "", prefix = prefix.toLowerCase().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
    }, Stash.prototype.createStoreKey = function(key) {
        if (key instanceof Array || null === key || void 0 === key) throw "Invalid key: " + key;
        return this.keyPrefix + key;
    }, Stash.prototype.get = function(key) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.get(self.createStoreKey(key), promise);
        });
    }, Stash.prototype.set = function(key, value) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.set(self.createStoreKey(key), value, promise);
        });
    }, Stash.prototype.promiseWrap = function(callback) {
        var deferred = Q ? Q.defer() : $.Deferred();
        return callback(deferred), Q ? deferred.promise : deferred.promise();
    }, Stash.prototype.getAll = function() {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.getAll(self.keyPrefix, promise);
        });
    }, Stash.prototype.update = function(key, value) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.update(self.createStoreKey(key), value, promise);
        });
    }, Stash.prototype.add = function(key, value) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.add(self.createStoreKey(key), value, promise);
        });
    }, Stash.prototype.remove = function(key) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.remove(self.createStoreKey(key), promise);
        });
    }, Stash.prototype.contains = function(key) {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.contains(self.createStoreKey(key), promise);
        });
    }, Stash.prototype.removeAll = function() {
        var self = this;
        return self.promiseWrap(function(promise) {
            self.provider.removeAll(promise);
        });
    };
    var providerFactory = function() {
        var availableProviders = [], namedProviders = {}, registerProvider = function(name, ProviderConstructor) {
            providerIsValid(name, ProviderConstructor) && (ProviderConstructor.prototype.stringify = stringify, 
            ProviderConstructor.prototype.unstringify = unstringify, ProviderConstructor.prototype.isType = isType, 
            ProviderConstructor.prototype.quoteStr = quoteStr, availableProviders.push(ProviderConstructor), 
            namedProviders[name] = ProviderConstructor);
        }, providerIsValid = function(name, Provider) {
            for (var methods = "get getAll set add update contains remove removeAll".split(" "), providerInstance = new Provider(), i = 0; i < methods.length; i++) {
                var method = methods[i];
                if (!providerInstance[method]) return console && console.error && console.error("Enduring Stash: Invalid provider! " + name + " provider is missing method " + method), 
                !1;
            }
            return !0;
        }, hasProvider = function() {
            return availableProviders.length > 0;
        }, getProvider = function() {
            if (hasProvider()) {
                var Provider = availableProviders[0];
                return new Provider();
            }
            return void 0;
        }, forceProvider = function(providerName) {
            var Provider = namedProviders[providerName] || void 0;
            return Provider ? new Provider() : null;
        }, isType = function(Ctor, value) {
            return void 0 !== value && null !== value && value.constructor === Ctor;
        }, quoteStr = function(str) {
            return "'" + String(str).replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") + "'";
        }, stringify = function(value) {
            if (isType(Date, value)) return "new Date(" + value.getTime() + ")";
            if (isType(Array, value)) {
                for (var arrayValues = [], i = 0; i < value.length; i++) arrayValues.push(stringify(value[i]));
                return "[" + arrayValues.join(",") + "]";
            }
            if (isType(Object, value)) {
                var objectValues = [];
                for (var property in value) objectValues.push(quoteStr(property) + ":" + stringify(value[property]));
                return "{" + objectValues.join(",") + "}";
            }
            return isType(RegExp, value) ? String(value) : JSON.stringify(value);
        }, unstringify = function(str) {
            return new Function("return " + str).apply();
        };
        return {
            hasProvider: hasProvider,
            getProvider: getProvider,
            forceProvider: forceProvider,
            registerProvider: registerProvider
        };
    }(), createStash = function(collection, providerName) {
        if (!providerFactory.hasProvider()) throw "Enduring Stash: No storage providers available! Include at least one provider.";
        var thisProvider = null;
        if (providerName) {
            if (thisProvider = providerFactory.forceProvider(providerName), !thisProvider) throw "Cannot force use of " + providerName + " provider - it is not available";
        } else thisProvider = providerFactory.getProvider();
        var stash = new Stash(collection, thisProvider);
        return stash;
    }, stashOf = function(collection, providerName) {
        return createStash(collection, providerName);
    }, stash = function() {
        return createStash("");
    };
    return {
        stash: stash,
        stashOf: stashOf,
        provider: providerFactory
    };
}();